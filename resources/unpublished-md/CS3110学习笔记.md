[toc]

<div id="tags">OCaml,DataStructure</div>

# Why

最初看到[CS3110][]这门课也挺巧合的，之前写这个网站的时候，用到了clojure下的一个库[clojure.zip][]，然后知道其中的实现是根据[Functional Perl The Zipper][]这篇paper实现的，尝试去读这篇论文的时候，看到里面用的sample使用OCaml写的，里面的第一句话就是：

> The main drawback to the purely applicative paradigm of programming is that
many efficient algorithms use destructive operations in data structures such as bit
vectors or character arrays or other mutable hierarchical classification structures,
which are not immediately modelled as purely applicative data structures. A well
known solution to this problem is called *functional arrays* (Paulson, 1991)

然而，我连function arrays在这里是指什么都不知道，于是google了下，碰巧就看到了[CS3110][]这门课，初略看了下，感觉挺有意思的一门课，所以打算完整学习下，提升下自己对Functional Programming的理解。

[CS3110]: http://www.cs.cornell.edu/courses/cs3110/2016fa/
[clojure.zip]: https://clojuredocs.org/clojure.zip
[Functional Perl The Zipper]: https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf

# LEC 1

这部分主要是关于FP的一些介绍，大部分内容在之前学习clojure的时候已经有所了解了，主要是关于immutability 和FP更elegant。有意思的是，在slides里看到了那句经典语句的出处：

> “A language that doesn't affect the
way you think about programming
is not worth knowing.”  -- Alan J. Perlis 

# LEC 2

学习一门编程语言的5个方面：

1. Syntax
2. Semantics
3. Idioms  （个人感觉这一点需要在反复读别人代码的过程中加深体会）
4. Libraries
5. Tools

有一个观点我觉得挺好，``We don’t complain about syntax``，可能做研究的人更看重一门语言背后的思想，至于语法层面的东西反而不太care。不过咱大多数人都比价肤浅点，因而一门语言是否能被广泛推广的重要原因之一就是语法是否友好......

在OCaml中每一个expression包含了type-checking。这点是这节课终点介绍的内容，需要注意的是，function也是一种value，其对应的type则是由function的输入和输出的type共通构成的。

后面的pipeline（即``|>``)与clojure中的``->``宏应该是一个意思。

> Every OCaml function takes exactly one argument.

这句话的意思应该是说，OCaml里的函数默认都是Currying了的。难怪在utop里打印出来的函数类型看起来都有点奇怪，一开始还很困惑如果返回值是函数的话为什么没有区分参数和返回值的类型。

# READING LIST

- [Introduction to Objective Caml](http://courses.cms.caltech.edu/cs134/cs134b/book.pdf)
- [Real World OCaml](https://realworldocaml.org/v1/en/html/a-guided-tour.html)